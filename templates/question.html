{% extends "base.html" %}

{% block title %}The Hancox Wedding Sweepstake{% endblock %}

{% block navbar %}{% endblock %}
{% block footer %}{% endblock %}

{% block content %}
<div class="question-container page-content d-flex align-items-center justify-content-center" style="min-height: 100vh;">
    <div style="width: 100%; max-width: 900px; padding: 20px;">
        <!-- Dot progress -->
        <div class="progress-dots">
            {% for i in range(total_questions) %}
            <div class="progress-dot {% if i < question_num %}completed{% elif i == question_num %}current{% endif %}"></div>
            {% endfor %}
        </div>

        <!-- Question -->
        <h2 class="question-text stagger-in" style="animation-delay: 0.05s;">{{ question.question_text }}</h2>
        <p class="question-quip stagger-in" style="animation-delay: 0.1s;">{{ quip }}</p>

        <!-- Input -->
        <form id="answerForm" class="stagger-in" style="animation-delay: 0.15s; margin: 30px 0;">
            {% if question.question_type == 'time' %}
            <div class="mb-4">
                <label for="timeSlider" class="form-label">Select time:</label>
                <div class="slider-nudge-row">
                    <button class="nudge-btn" id="timeMinus" type="button" aria-label="Decrease">−</button>
                    <div class="slider-wrapper">
                        <div class="slider-floating-value" id="floatingValue">--:--</div>
                        <input type="range" class="form-range" id="timeSlider"
                               min="0" max="100" value="50"
                               data-min-time="{{ question.min or '00:00' }}"
                               data-max-time="{{ question.max or '23:59' }}"
                               style="height: 30px;">
                    </div>
                    <button class="nudge-btn" id="timePlus" type="button" aria-label="Increase">+</button>
                </div>
                <div class="slider-labels">
                    <span class="slider-min">{{ question.min or '00:00' }}</span>
                    <span class="slider-max">{{ question.max or '23:59' }}</span>
                </div>
                <input type="hidden" id="timeInput" value="{{ current_answer }}">
            </div>
            {% else %}
            {% set min_val = question.min if question.min is not none else 0 %}
            {% set max_val = question.max if question.max is not none else 100 %}
            {% set mid_val = ((min_val + max_val) / 2) | int %}
            <div class="mb-4">
                <label for="numberSlider" class="form-label">Select your guess:</label>
                <div class="slider-nudge-row">
                    <button class="nudge-btn" id="numberMinus" type="button" aria-label="Decrease">−</button>
                    <div class="slider-wrapper">
                        <div class="slider-floating-value" id="floatingValue">{{ current_answer or mid_val }}</div>
                        <input type="range" class="form-range" id="numberSlider"
                               min="{{ min_val }}" max="{{ max_val }}"
                               value="{{ current_answer or mid_val }}"
                               style="height: 30px;">
                    </div>
                    <button class="nudge-btn" id="numberPlus" type="button" aria-label="Increase">+</button>
                </div>
                <div class="slider-labels">
                    <span class="slider-min">{{ min_val }}</span>
                    <span class="slider-max">{{ max_val }}</span>
                </div>
                <div class="slider-unit">{{ question.unit }}</div>
                <input type="hidden" id="numberInput" value="{{ current_answer or mid_val }}">
            </div>
            {% endif %}
        </form>

        <!-- Nav buttons -->
        <div class="d-grid gap-3 mb-3 stagger-in" style="animation-delay: 0.2s;">
            <button type="button" class="btn btn-primary btn-lg" onclick="nextQuestion()" style="padding: 18px; font-size: 18px;">
                {% if question_num + 1 < total_questions %}Next Question{% else %}Review Answers{% endif %}
            </button>
        </div>

        <div class="d-grid gap-3 stagger-in" style="animation-delay: 0.25s;">
            {% if question_num > 0 %}
            <button type="button" class="btn btn-outline-secondary btn-lg" onclick="previousQuestion()" style="padding: 14px; font-size: 16px;">
                Previous Question
            </button>
            {% endif %}
            <button type="button" class="btn btn-outline-danger btn-sm" onclick="showCancelModal()" style="padding: 10px;">
                Cancel
            </button>
        </div>
    </div>
</div>

<!-- Cancel Modal -->
<div class="modal-overlay" id="cancelModal">
    <div class="custom-modal">
        <h4>Cancel Game?</h4>
        <p>Are you sure you want to cancel? Your answers will be lost.</p>
        <div class="modal-buttons">
            <button type="button" class="btn btn-secondary" onclick="hideCancelModal()">Go Back</button>
            <button type="button" class="btn btn-danger" onclick="confirmCancel()">Yes, Cancel</button>
        </div>
    </div>
</div>

<script>
const questionId = {{ question.id }};
const questionNum = {{ question_num }};
const totalQuestions = {{ total_questions }};
const questionType = '{{ question.question_type }}';

function navigateWithFade(url) {
    document.querySelector('.page-content').classList.add('fade-out');
    setTimeout(() => { window.location.href = url; }, 300);
}

// Slider position tracking for floating value and filled track
let lastValue = 0;
let lastTime = Date.now();
let speedGlowTimeout = null;

function updateSliderUI(slider, displayValue) {
    const min = parseFloat(slider.min);
    const max = parseFloat(slider.max);
    const val = parseFloat(slider.value);
    const pct = ((val - min) / (max - min)) * 100;

    // Update filled track
    slider.style.setProperty('--slider-progress', pct + '%');

    // Position floating value above thumb
    const floatingEl = document.getElementById('floatingValue');
    const sliderRect = slider.getBoundingClientRect();
    const thumbOffset = (pct / 100) * sliderRect.width;
    floatingEl.style.left = thumbOffset + 'px';
    floatingEl.textContent = displayValue;

    // Speed-reactive glow
    const now = Date.now();
    const dt = now - lastTime;
    const dv = Math.abs(val - lastValue);
    const speed = dt > 0 ? dv / dt : 0;

    if (speed > 0.3) {
        floatingEl.classList.add('speed-glow');
        clearTimeout(speedGlowTimeout);
        speedGlowTimeout = setTimeout(() => {
            floatingEl.classList.remove('speed-glow');
        }, 200);
    }

    lastValue = val;
    lastTime = now;

    // Haptic feedback
    if (navigator.vibrate && dv > 0) {
        navigator.vibrate(1);
    }
}

{% if question.question_type == 'time' %}
const timeSlider = document.getElementById('timeSlider');
const timeInput = document.getElementById('timeInput');

function timeToMinutes(timeStr) {
    const [hours, minutes] = timeStr.split(':').map(Number);
    return hours * 60 + minutes;
}

function minutesToTime(minutes) {
    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    return hours.toString().padStart(2, '0') + ':' + mins.toString().padStart(2, '0');
}

const minTime = timeSlider.dataset.minTime || '00:00';
const maxTime = timeSlider.dataset.maxTime || '23:59';
const minMinutes = timeToMinutes(minTime);
const maxMinutes = timeToMinutes(maxTime);
const range = maxMinutes - minMinutes;

function updateTimeDisplay() {
    const sliderValue = parseInt(timeSlider.value);
    const currentMinutes = minMinutes + Math.round((sliderValue / 100) * range);
    const timeStr = minutesToTime(currentMinutes);
    timeInput.value = timeStr;
    updateSliderUI(timeSlider, timeStr);
}

const savedAnswer = '{{ current_answer }}';
if (savedAnswer) {
    const savedMinutes = timeToMinutes(savedAnswer);
    const sliderPos = ((savedMinutes - minMinutes) / range) * 100;
    timeSlider.value = Math.round(sliderPos);
} else {
    timeSlider.value = 50;
}
updateTimeDisplay();
timeSlider.addEventListener('input', updateTimeDisplay);

function getAnswer() { return timeInput.value; }

// --- Time nudge buttons ---
function snapToNextFiveTime(val, direction) {
    if (direction > 0) return Math.min(maxMinutes, Math.ceil((val + 0.01) / 5) * 5);
    return Math.max(minMinutes, Math.floor((val - 0.01) / 5) * 5);
}

function applyTimeNudge(direction, isHold) {
    let currentMins = timeToMinutes(timeInput.value || minutesToTime(
        minMinutes + Math.round((timeSlider.value / 100) * range)
    ));
    if (isHold) {
        currentMins = snapToNextFiveTime(currentMins, direction);
    } else {
        currentMins = Math.min(maxMinutes, Math.max(minMinutes, currentMins + direction));
    }
    timeSlider.value = Math.round(((currentMins - minMinutes) / range) * 100);
    updateTimeDisplay();
}

(function attachTimeNudge() {
    let nudgeTimer = null, nudgeInterval = null, nudgeTriggeredHold = false;
    function startNudge(direction) {
        nudgeTriggeredHold = false;
        nudgeTimer = setTimeout(() => {
            nudgeTriggeredHold = true;
            applyTimeNudge(direction, true);
            nudgeInterval = setInterval(() => applyTimeNudge(direction, true), 150);
        }, 500);
    }
    function stopNudge(direction) {
        clearTimeout(nudgeTimer); clearInterval(nudgeInterval);
        if (!nudgeTriggeredHold) applyTimeNudge(direction, false);
    }
    function attach(id, direction) {
        const btn = document.getElementById(id);
        btn.addEventListener('pointerdown', () => startNudge(direction));
        btn.addEventListener('pointerup', () => stopNudge(direction));
        btn.addEventListener('pointercancel', () => { clearTimeout(nudgeTimer); clearInterval(nudgeInterval); nudgeTriggeredHold = true; });
        btn.addEventListener('pointerleave', () => { clearTimeout(nudgeTimer); clearInterval(nudgeInterval); nudgeTriggeredHold = true; });
    }
    attach('timeMinus', -1);
    attach('timePlus', 1);
})();

{% else %}
const numberSlider = document.getElementById('numberSlider');
const numberInput = document.getElementById('numberInput');

function updateNumberDisplay() {
    numberInput.value = numberSlider.value;
    updateSliderUI(numberSlider, numberSlider.value);
}

updateNumberDisplay();
numberSlider.addEventListener('input', updateNumberDisplay);

function getAnswer() { return numberInput.value; }

// --- Number nudge buttons ---
function snapToNextFiveNum(val, direction, min, max) {
    if (direction > 0) return Math.min(max, Math.ceil((val + 0.01) / 5) * 5);
    return Math.max(min, Math.floor((val - 0.01) / 5) * 5);
}

function applyNumberNudge(direction, isHold) {
    const min = parseFloat(numberSlider.min), max = parseFloat(numberSlider.max);
    let val = parseFloat(numberSlider.value);
    if (isHold) {
        val = snapToNextFiveNum(val, direction, min, max);
    } else {
        val = Math.min(max, Math.max(min, val + direction));
    }
    numberSlider.value = val;
    updateNumberDisplay();
}

(function attachNumberNudge() {
    let nudgeTimer = null, nudgeInterval = null, nudgeTriggeredHold = false;
    function startNudge(direction) {
        nudgeTriggeredHold = false;
        nudgeTimer = setTimeout(() => {
            nudgeTriggeredHold = true;
            applyNumberNudge(direction, true);
            nudgeInterval = setInterval(() => applyNumberNudge(direction, true), 150);
        }, 500);
    }
    function stopNudge(direction) {
        clearTimeout(nudgeTimer); clearInterval(nudgeInterval);
        if (!nudgeTriggeredHold) applyNumberNudge(direction, false);
    }
    function attach(id, direction) {
        const btn = document.getElementById(id);
        btn.addEventListener('pointerdown', () => startNudge(direction));
        btn.addEventListener('pointerup', () => stopNudge(direction));
        btn.addEventListener('pointercancel', () => { clearTimeout(nudgeTimer); clearInterval(nudgeInterval); nudgeTriggeredHold = true; });
        btn.addEventListener('pointerleave', () => { clearTimeout(nudgeTimer); clearInterval(nudgeInterval); nudgeTriggeredHold = true; });
    }
    attach('numberMinus', -1);
    attach('numberPlus', 1);
})();
{% endif %}

async function saveAnswer() {
    const answer = getAnswer();
    if (!answer) { alert('Please select an answer'); return false; }
    try {
        const response = await fetch('/answer/' + questionId, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify({ answer: answer })
        });
        if (response.ok) return true;
        const data = await response.json();
        alert(data.error || 'Error saving answer');
        return false;
    } catch (error) {
        console.error('Error saving answer:', error);
        alert('Error saving answer');
        return false;
    }
}

async function nextQuestion() {
    if (await saveAnswer()) {
        if (questionNum + 1 < totalQuestions) {
            navigateWithFade('/question/' + (questionNum + 1));
        } else {
            navigateWithFade('/summary');
        }
    }
}

function previousQuestion() {
    if (questionNum > 0) navigateWithFade('/question/' + (questionNum - 1));
}

function showCancelModal() { document.getElementById('cancelModal').classList.add('active'); }
function hideCancelModal() { document.getElementById('cancelModal').classList.remove('active'); }
function confirmCancel() { hideCancelModal(); navigateWithFade('/'); }
</script>
{% endblock %}
